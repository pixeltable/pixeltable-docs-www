---
title: "Query"
icon: "square-c"
description: "<a href=\"https://github.com/pixeltable/pixeltable/blob/main/pixeltable/_query.py#L176\" id=\"viewSource\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/View%20Source%20on%20Github-blue?logo=github&labelColor=gray\" alt=\"View Source on GitHub\" style={{ display: 'inline', margin: '0px' }} noZoom /></a>"
---
# <span style={{ 'color': 'gray' }}>class</span>&nbsp; pixeltable.Query


Represents a query for retrieving and transforming data from Pixeltable tables.


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; collect()

```python Signature
collect() -> ResultSet
```


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; distinct()

```python Signature
distinct() -> Query
```

Remove duplicate rows from this Query.

Note that grouping will be applied to the rows based on the select clause of this Query.
In the absence of a select clause, by default, all columns are selected in the grouping.

**Examples:**

Select unique addresses from table `addresses`.
```python
results = addresses.distinct()
```

Select unique cities in table `addresses`
```python
results = addresses.city.distinct()
```

Select unique locations (street, city) in the state of `CA`
```python
results = (
    addresses.select(addresses.street, addresses.city)
    .where(addresses.state == 'CA')
    .distinct()
)
```


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; group_by()

```python Signature
group_by(*grouping_items: Any) -> Query
```

Add a group-by clause to this Query.

Variants:
- group_by(base_tbl): group a component view by their respective base table rows
- group_by(expr1, expr2, expr3): group by the given expressions

Note that grouping will be applied to the rows and take effect when
used with an aggregation function like sum(), count() etc.

**Parameters:**

- **`grouping_items`** (`Any`): expressions to group by

**Returns:**

- `Query`: A new Query with the specified group-by clause.

**Examples:**

Given the Query book from a table t with all its columns and rows:
```python
book = t.select()
```

Group the above Query book by the 'genre' column (referenced in table t):
```python
query = book.group_by(t.genre)
```

Use the above Query grouped by genre to count the number of books for each 'genre':
```python
query = (
    book.group_by(t.genre).select(t.genre, count=count(t.genre)).show()
)
```

Use the above Query grouped by genre to the total price of books for each 'genre':
```python
query = book.group_by(t.genre).select(t.genre, total=sum(t.price)).show()
```


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; head()

```python Signature
head(n: int = 10) -> ResultSet
```

Return the first n rows of the Query, in insertion order of the underlying Table.

head() is not supported for joins.

**Parameters:**

- **`n`** (`int`, default: `10`): Number of rows to select. Default is 10.

**Returns:**

- `ResultSet`: A ResultSet with the first n rows of the Query.


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; join()

```python Signature
join(
    other: catalog.Table,
    on: exprs.Expr | Sequence[exprs.ColumnRef] | None = None,
    how: plan.JoinType.LiteralType = 'inner'
) -> Query
```

Join this Query with a table.


**Parameters:**

- **`other`** (`catalog.Table`): the table to join with
- **`on`** (`exprs.Expr | Sequence[exprs.ColumnRef] | None`): the join condition, which can be either a) references to one or more columns or b) a boolean
    expression.

    - column references: implies an equality predicate that matches columns in both this
        Query and `other` by name.

        - column in `other`: A column with that same name must be present in this Query, and **it must
            be unique** (otherwise the join is ambiguous).
        - column in this Query: A column with that same name must be present in `other`.

    - boolean expression: The expressions must be valid in the context of the joined tables.
- **`how`** (`plan.JoinType.LiteralType`, default: `'inner'`): the type of join to perform.
    - `'inner'`: only keep rows that have a match in both
    - `'left'`: keep all rows from this Query and only matching rows from the other table
    - `'right'`: keep all rows from the other table and only matching rows from this Query
    - `'full_outer'`: keep all rows from both this Query and the other table
    - `'cross'`: Cartesian product; no `on` condition allowed

**Returns:**

- `Query`: A new Query.

**Examples:**

Perform an inner join between t1 and t2 on the column id:
```python
join1 = t1.join(t2, on=t2.id)
```

Perform a left outer join of join1 with t3, also on id (note that we can't specify `on=t3.id` here, because that would be ambiguous, since both t1 and t2 have a column named id):
```python
join2 = join1.join(t3, on=t2.id, how='left')
```

Do the same, but now with an explicit join predicate:
```python
join2 = join1.join(t3, on=t2.id == t3.id, how='left')
```

Join t with d, which has a composite primary key (columns pk1 and pk2, with corresponding foreign key columns d1 and d2 in t):
```python
query = t.join(d, on=(t.d1 == d.pk1) & (t.d2 == d.pk2), how='left')
```


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; limit()

```python Signature
limit(n: int) -> Query
```

Limit the number of rows in the Query.


**Parameters:**

- **`n`** (`int`): Number of rows to select.

**Returns:**

- `Query`: A new Query with the specified limited rows.


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; order_by()

```python Signature
order_by(*expr_list: exprs.Expr, asc: bool = True) -> Query
```

Add an order-by clause to this Query.


**Parameters:**

- **`expr_list`** (`exprs.Expr`): expressions to order by
- **`asc`** (`bool`, default: `True`): whether to order in ascending order (True) or descending order (False).
    Default is True.

**Returns:**

- `Query`: A new Query with the specified order-by clause.

**Examples:**

Given the Query book from a table t with all its columns and rows:
```python
book = t.select()
```

Order the above Query book by two columns (price, pages) in descending order:
```python
query = book.order_by(t.price, t.pages, asc=False)
```

Order the above Query book by price in descending order, but order the pages in ascending order:
```python
query = book.order_by(t.price, asc=False).order_by(t.pages)
```


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; sample()

```python Signature
sample(
    n: int | None = None,
    n_per_stratum: int | None = None,
    fraction: float | None = None,
    seed: int | None = None,
    stratify_by: Any = None
) -> Query
```

Return a new Query specifying a sample of rows from the Query, considered in a shuffled order.

The size of the sample can be specified in three ways:

- `n`: the total number of rows to produce as a sample
- `n_per_stratum`: the number of rows to produce per stratum as a sample
- `fraction`: the fraction of available rows to produce as a sample

The sample can be stratified by one or more columns, which means that the sample will
be selected from each stratum separately.

The data is shuffled before creating the sample.

**Parameters:**

- **`n`** (`int | None`): Total number of rows to produce as a sample.
- **`n_per_stratum`** (`int | None`): Number of rows to produce per stratum as a sample. This parameter is only valid if
    `stratify_by` is specified. Only one of `n` or `n_per_stratum` can be specified.
- **`fraction`** (`float | None`): Fraction of available rows to produce as a sample. This parameter is not usable with `n` or
    `n_per_stratum`. The fraction must be between 0.0 and 1.0.
- **`seed`** (`int | None`): Random seed for reproducible shuffling
- **`stratify_by`** (`Any`): If specified, the sample will be stratified by these values.

**Returns:**

- `Query`: A new Query which specifies the sampled rows

**Examples:**

Given the Table `person` containing the field 'age', we can create samples of the table in various ways: Sample 100 rows from the above Table:
```python
query = person.sample(n=100)
```

Sample 10% of the rows from the above Table:
```python
query = person.sample(fraction=0.1)
```

Sample 10% of the rows from the above Table, stratified by the column 'age':
```python
query = person.sample(fraction=0.1, stratify_by=t.age)
```

Equal allocation sampling: Sample 2 rows from each age present in the above Table:
```python
query = person.sample(n_per_stratum=2, stratify_by=t.age)
```

Sampling is compatible with the where clause, so we can also sample from a filtered Query:
```python
query = person.where(t.age > 30).sample(n=100)
```


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; select()

```python Signature
select(*items: Any, **named_items: Any) -> Query
```

Select columns or expressions from the Query.


**Parameters:**

- **`items`** (`Any`): expressions to be selected
- **`named_items`** (`Any`): named expressions to be selected

**Returns:**

- `Query`: A new Query with the specified select list.

**Examples:**

Given the Query person from a table t with all its columns and rows:
```python
person = t.select()
```

Select the columns 'name' and 'age' (referenced in table t) from the Query person:
```python
query = person.select(t.name, t.age)
```

Select the columns 'name' (referenced in table t) from the Query person, and a named column 'is_adult' from the expression `age >= 18` where 'age' is another column in table t:
```python
query = person.select(t.name, is_adult=(t.age >= 18))
```


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; show()

```python Signature
show(n: int = 20) -> ResultSet
```


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; tail()

```python Signature
tail(n: int = 10) -> ResultSet
```

Return the last n rows of the Query, in insertion order of the underlying Table.

tail() is not supported for joins.

**Parameters:**

- **`n`** (`int`, default: `10`): Number of rows to select. Default is 10.

**Returns:**

- `ResultSet`: A ResultSet with the last n rows of the Query.


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; to_coco_dataset()

```python Signature
to_coco_dataset() -> Path
```

Convert the Query to a COCO dataset.
This Query must return a single json-typed output column in the following format:

```python
{
    'image': PIL.Image.Image,
    'annotations': [
        {
            'bbox': [x: int, y: int, w: int, h: int],
            'category': str | int,
        },
        ...
    ],
}
```

**Returns:**

- `Path`: Path to the COCO dataset file.


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; to_pytorch_dataset()

```python Signature
to_pytorch_dataset(image_format: str = 'pt') -> torch.utils.data.IterableDataset
```

Convert the Query to a pytorch IterableDataset suitable for parallel loading
with torch.utils.data.DataLoader.

This method requires pyarrow >= 13, torch and torchvision to work.

This method serializes data so it can be read from disk efficiently and repeatedly without
re-executing the query. This data is cached to disk for future re-use.

**Parameters:**

- **`image_format`** (`str`, default: `'pt'`): format of the images. Can be 'pt' (pytorch tensor) or 'np' (numpy array).
    'np' means image columns return as an RGB uint8 array of shape HxWxC.
    'pt' means image columns return as a CxHxW tensor with values in [0,1] and type torch.float32.
        (the format output by torchvision.transforms.ToTensor())

**Returns:**

- `'torch.utils.data.IterableDataset'`: A pytorch IterableDataset: Columns become fields of the dataset, where rows are returned as a dictionary
  compatible with torch.utils.data.DataLoader default collation.


## <span style={{ 'color': 'gray' }}>method</span>&nbsp; where()

```python Signature
where(pred: exprs.Expr) -> Query
```

Filter rows based on a predicate.


**Parameters:**

- **`pred`** (`exprs.Expr`): the predicate to filter rows

**Returns:**

- `Query`: A new Query with the specified predicates replacing the where-clause.

**Examples:**

Given the Query person from a table t with all its columns and rows:
```python
person = t.select()
```

Filter the above Query person to only include rows where the column 'age' (referenced in table t) is greater than 30:
```python
query = person.where(t.age > 30)
```

## <span style={{ 'color': 'gray' }}>attr</span>&nbsp; schema

```
schema: dict[str, ColumnType]
```

Column names and types in this Query.

