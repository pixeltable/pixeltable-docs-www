---
title: "huggingface"
icon: "square-m"
description: "<a href=\"https://github.com/pixeltable/pixeltable/blob/main/pixeltable/functions/huggingface.py#L0\" id=\"viewSource\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/View%20Source%20on%20Github-blue?logo=github&labelColor=gray\" alt=\"View Source on GitHub\" style={{ display: 'inline', margin: '0px' }} noZoom /></a>"
---
# <span style={{ 'color': 'gray' }}>module</span>&nbsp; pixeltable.functions.huggingface


Pixeltable UDFs
that wrap various models from the Hugging Face `transformers` package.

These UDFs will cause Pixeltable to invoke the relevant models locally. In order to use them, you must
first `pip install transformers` (or in some cases, `sentence-transformers`, as noted in the specific
UDFs).

## UDFs


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; automatic_speech_recognition()

```python Signature
@pxt.udf
automatic_speech_recognition(
    audio: pxt.Audio,
    *,
    model_id: pxt.String,
    language: pxt.String | None = None,
    chunk_length_s: pxt.Int | None = None,
    return_timestamps: pxt.Bool = False
) -> pxt.String
```

Transcribes speech to text using a pretrained ASR model. `model_id` should be a reference to a
pretrained [automatic-speech-recognition model](https://huggingface.co/models?pipeline_tag=automatic-speech-recognition).

This is a **generic function** that works with many ASR model families. For production use with
specific models, consider specialized functions like `whisper.transcribe()` or
`speech2text_for_conditional_generation()`.

__Requirements:__

- `pip install torch transformers torchaudio`

__Recommended Models:__

- **OpenAI Whisper**: `openai/whisper-tiny.en`, `openai/whisper-small`, `openai/whisper-base`
- **Facebook Wav2Vec2**: `facebook/wav2vec2-base-960h`, `facebook/wav2vec2-large-960h-lv60-self`
- **Microsoft SpeechT5**: `microsoft/speecht5_asr`
- **Meta MMS (Multilingual)**: `facebook/mms-1b-all`

**Parameters:**

- **`audio`** (`pxt.Audio`): The audio file(s) to transcribe.
- **`model_id`** (`pxt.String`): The pretrained ASR model to use.
- **`language`** (`pxt.String | None`): Language code for multilingual models (e.g., 'en', 'es', 'fr').
- **`chunk_length_s`** (`pxt.Int | None`): Maximum length of audio chunks in seconds for long audio processing.
- **`return_timestamps`** (`pxt.Bool`): Whether to return word-level timestamps (model dependent).

**Returns:**

- `pxt.String`: The transcribed text.

**Examples:**

Add a computed column that transcribes audio files:
```python
tbl.add_computed_column(
    transcription=automatic_speech_recognition(
        tbl.audio_file,
        model_id='openai/whisper-tiny.en',  # Recommended
    )
)
```

Transcribe with language specification:
```python
tbl.add_computed_column(
    transcription=automatic_speech_recognition(
        tbl.audio_file, model_id='facebook/mms-1b-all', language='en'
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; clip()

```python Signatures
# Signature 1:
@pxt.udf
clip(
    text: pxt.String,
    model_id: pxt.String
) -> pxt.Array[(None,), float32]

# Signature 2:
@pxt.udf
clip(
    image: pxt.Image,
    model_id: pxt.String
) -> pxt.Array[(None,), float32]
```

Computes a CLIP embedding for the specified text or image. `model_id` should be a reference to a pretrained
[CLIP Model](https://huggingface.co/docs/transformers/model_doc/clip).

__Requirements:__

- `pip install torch transformers`

**Parameters:**

- **`text`** (`String`): The string to embed.
- **`model_id`** (`String`): The pretrained model to use for the embedding.

**Returns:**

- `pxt.Array[(None,), float32]`: An array containing the output of the embedding model.

**Examples:**

Add a computed column that applies the model `openai/clip-vit-base-patch32` to an existing Pixeltable column `tbl.text` of the table `tbl`:
```python
tbl.add_computed_column(
    result=clip(tbl.text, model_id='openai/clip-vit-base-patch32')
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; cross_encoder()

```python Signature
@pxt.udf
cross_encoder(
    sentences1: pxt.String,
    sentences2: pxt.String,
    *,
    model_id: pxt.String
) -> pxt.Float
```

Performs predicts on the given sentence pair.
`model_id` should be a pretrained Cross-Encoder model, as described in the
[Cross-Encoder Pretrained Models](https://www.sbert.net/docs/cross_encoder/pretrained_models.html)
documentation.

__Requirements:__

- `pip install torch sentence-transformers`

**Parameters:**

- **`sentences1`** (`pxt.String`): The first sentence to be paired.
- **`sentences2`** (`pxt.String`): The second sentence to be paired.
- **`model_id`** (`pxt.String`): The identifier of the cross-encoder model to use.

**Returns:**

- `pxt.Float`: The similarity score between the inputs.

**Examples:**

Add a computed column that applies the model `ms-marco-MiniLM-L-4-v2` to the sentences in columns `tbl.sentence1` and `tbl.sentence2`:
```python
tbl.add_computed_column(
    result=sentence_transformer(
        tbl.sentence1, tbl.sentence2, model_id='ms-marco-MiniLM-L-4-v2'
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; detr_for_object_detection()

```python Signature
@pxt.udf
detr_for_object_detection(
    image: pxt.Image,
    *,
    model_id: pxt.String,
    threshold: pxt.Float = 0.5,
    revision: pxt.String = 'no_timm'
) -> pxt.Json
```

Computes DETR object detections for the specified image. `model_id` should be a reference to a pretrained
[DETR Model](https://huggingface.co/docs/transformers/model_doc/detr).

__Requirements:__

- `pip install torch transformers`

**Parameters:**

- **`image`** (`pxt.Image`): The image to embed.
- **`model_id`** (`pxt.String`): The pretrained model to use for object detection.

**Returns:**

- `pxt.Json`: A dictionary containing the output of the object detection model, in the following format:
  ```python
  {
      'scores': [0.99, 0.999],  # list of confidence scores for each detected object
      'labels': [25, 25],  # list of COCO class labels for each detected object
      'label_text': ['giraffe', 'giraffe'],  # corresponding text names of class labels
      'boxes': [[51.942, 356.174, 181.481, 413.975], [383.225, 58.66, 605.64, 361.346]]
          # list of bounding boxes for each detected object, as [x1, y1, x2, y2]
  }
  ```

**Examples:**

Add a computed column that applies the model `facebook/detr-resnet-50` to an existing Pixeltable column `image` of the table `tbl`:
```python
tbl.add_computed_column(
    detections=detr_for_object_detection(
        tbl.image, model_id='facebook/detr-resnet-50', threshold=0.8
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; detr_for_segmentation()

```python Signature
@pxt.udf
detr_for_segmentation(
    image: pxt.Image,
    *,
    model_id: pxt.String,
    threshold: pxt.Float = 0.5
) -> pxt.Json
```

Computes DETR panoptic segmentation for the specified image. `model_id` should be a reference to a pretrained
[DETR Model](https://huggingface.co/docs/transformers/model_doc/detr) with a segmentation head.

__Requirements:__

- `pip install torch transformers timm`

**Parameters:**

- **`image`** (`pxt.Image`): The image to segment.
- **`model_id`** (`pxt.String`): The pretrained model to use for segmentation (e.g., 'facebook/detr-resnet-50-panoptic').
- **`threshold`** (`pxt.Float`): Confidence threshold for filtering segments.

**Returns:**

- `pxt.Json`: A dictionary containing the output of the segmentation model, in the following format:
  ```python
  {
      'segmentation': np.ndarray,  # (H, W) array where each pixel value is a segment ID
      'segments_info': [
          {
              'id': 1,  # segment ID (matches pixel values in segmentation array)
              'label_id': 0,  # class label index
              'label_text': 'person',  # human-readable class name
              'score': 0.98,  # confidence score
              'was_fused': False  # whether segment was fused from multiple instances
          },
          ...
      ]
  }
  ```

**Examples:**

Add a computed column that applies the model `facebook/detr-resnet-50-panoptic` to an existing Pixeltable column `image` of the table `tbl`:
```python
tbl.add_computed_column(
    segmentation=detr_for_segmentation(
        tbl.image,
        model_id='facebook/detr-resnet-50-panoptic',
        threshold=0.5,
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; detr_to_coco()

```python Signature
@pxt.udf
detr_to_coco(image: pxt.Image, detr_info: pxt.Json) -> pxt.Json
```

Converts the output of a DETR object detection model to COCO format.


**Parameters:**

- **`image`** (`pxt.Image`): The image for which detections were computed.
- **`detr_info`** (`pxt.Json`): The output of a DETR object detection model, as returned by `detr_for_object_detection`.

**Returns:**

- `pxt.Json`: A dictionary containing the data from `detr_info`, converted to COCO format.

**Examples:**

Add a computed column that converts the output `tbl.detections` to COCO format, where `tbl.image` is the image for which detections were computed:
```python
tbl.add_computed_column(
    detections_coco=detr_to_coco(tbl.image, tbl.detections)
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; image_captioning()

```python Signature
@pxt.udf
image_captioning(
    image: pxt.Image,
    *,
    model_id: pxt.String,
    model_kwargs: pxt.Json | None = None
) -> pxt.String
```

Generates captions for images using a pretrained image captioning model. `model_id` should be a reference to a
pretrained [image-to-text model](https://huggingface.co/models?pipeline_tag=image-to-text) such as BLIP,
Git, or LLaVA.

__Requirements:__

- `pip install torch transformers`

**Parameters:**

- **`image`** (`pxt.Image`): The image to caption.
- **`model_id`** (`pxt.String`): The pretrained model to use for captioning.
- **`model_kwargs`** (`pxt.Json | None`): Additional keyword arguments to pass to the model's `generate` method, such as `max_length`.

**Returns:**

- `pxt.String`: The generated caption text.

**Examples:**

Add a computed column `caption` to an existing table `tbl` that generates captions using the `Salesforce/blip-image-captioning-base` model:
```python
tbl.add_computed_column(
    caption=image_captioning(
        tbl.image,
        model_id='Salesforce/blip-image-captioning-base',
        model_kwargs={'max_length': 30},
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; image_to_image()

```python Signature
@pxt.udf
image_to_image(
    image: pxt.Image,
    prompt: pxt.String,
    *,
    model_id: pxt.String,
    seed: pxt.Int | None = None,
    model_kwargs: pxt.Json | None = None
) -> pxt.Image
```

Transforms input images based on text prompts using a pretrained image-to-image model.
`model_id` should be a reference to a pretrained
[image-to-image model](https://huggingface.co/models?pipeline_tag=image-to-image) such as
Stable Diffusion.

__Requirements:__

- `pip install torch transformers diffusers accelerate`

**Parameters:**

- **`image`** (`pxt.Image`): The input image to transform.
- **`prompt`** (`pxt.String`): The text prompt describing the desired transformation.
- **`model_id`** (`pxt.String`): The pretrained image-to-image model to use.
- **`seed`** (`pxt.Int | None`): Random seed for reproducibility.
- **`model_kwargs`** (`pxt.Json | None`): Additional keyword arguments to pass to the model, such as `strength`,
    `guidance_scale`, or `num_inference_steps`.

**Returns:**

- `pxt.Image`: The transformed image.

**Examples:**

Add a computed column that transforms images based on prompts:
```python
tbl.add_computed_column(
    transformed=image_to_image(
        tbl.source_image,
        tbl.transformation_prompt,
        model_id='stable-diffusion-v1-5/stable-diffusion-v1-5',
    )
)
```

With custom transformation strength:
```python
tbl.add_computed_column(
    transformed=image_to_image(
        tbl.source_image,
        tbl.transformation_prompt,
        model_id='stable-diffusion-v1-5/stable-diffusion-v1-5',
        model_kwargs={'strength': 0.75, 'num_inference_steps': 50},
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; image_to_video()

```python Signature
@pxt.udf
image_to_video(
    image: pxt.Image,
    *,
    model_id: pxt.String,
    num_frames: pxt.Int = 25,
    fps: pxt.Int = 6,
    seed: pxt.Int | None = None,
    model_kwargs: pxt.Json | None = None
) -> pxt.Video
```

Generates videos from input images using a pretrained image-to-video model.
`model_id` should be a reference to a pretrained
[image-to-video model](https://huggingface.co/models?pipeline_tag=image-to-video).

__Requirements:__

- `pip install torch transformers diffusers accelerate`

**Parameters:**

- **`image`** (`pxt.Image`): The input image to animate into a video.
- **`model_id`** (`pxt.String`): The pretrained image-to-video model to use.
- **`num_frames`** (`pxt.Int`): Number of video frames to generate.
- **`fps`** (`pxt.Int`): Frames per second for the output video.
- **`seed`** (`pxt.Int | None`): Random seed for reproducibility.
- **`model_kwargs`** (`pxt.Json | None`): Additional keyword arguments to pass to the model, such as `num_inference_steps`,
    `motion_bucket_id`, or `guidance_scale`.

**Returns:**

- `pxt.Video`: The generated video file.

**Examples:**

Add a computed column that creates videos from images:
```python
tbl.add_computed_column(
    video=image_to_video(
        tbl.input_image,
        model_id='stabilityai/stable-video-diffusion-img2vid-xt',
        num_frames=25,
        fps=7,
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; question_answering()

```python Signature
@pxt.udf
question_answering(
    context: pxt.String,
    question: pxt.String,
    *,
    model_id: pxt.String
) -> pxt.Json
```

Answers questions based on provided context using a pretrained QA model. `model_id` should be a reference to a
pretrained [question answering model](https://huggingface.co/models?pipeline_tag=question-answering) such as
BERT or RoBERTa.

__Requirements:__

- `pip install torch transformers`

**Parameters:**

- **`context`** (`pxt.String`): The context text containing the answer.
- **`question`** (`pxt.String`): The question to answer.
- **`model_id`** (`pxt.String`): The pretrained QA model to use.

**Returns:**

- `pxt.Json`: A dictionary containing the answer, confidence score, and start/end positions.

**Examples:**

Add a computed column that answers questions based on document context:
```python
tbl.add_computed_column(
    answer=question_answering(
        tbl.document_text,
        tbl.question,
        model_id='deepset/roberta-base-squad2',
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; sentence_transformer()

```python Signature
@pxt.udf
sentence_transformer(
    sentence: pxt.String,
    *,
    model_id: pxt.String,
    normalize_embeddings: pxt.Bool = False
) -> pxt.Array[(None,), float32]
```

Computes sentence embeddings. `model_id` should be a pretrained Sentence Transformers model, as described
in the [Sentence Transformers Pretrained Models](https://sbert.net/docs/sentence_transformer/pretrained_models.html)
documentation.

__Requirements:__

- `pip install torch sentence-transformers`

**Parameters:**

- **`sentence`** (`pxt.String`): The sentence to embed.
- **`model_id`** (`pxt.String`): The pretrained model to use for the encoding.
- **`normalize_embeddings`** (`pxt.Bool`): If `True`, normalizes embeddings to length 1; see the
    [Sentence Transformers API Docs](https://sbert.net/docs/package_reference/sentence_transformer/SentenceTransformer.html)
    for more details

**Returns:**

- `pxt.Array[(None,), float32]`: An array containing the output of the embedding model.

**Examples:**

Add a computed column that applies the model `all-mpnet-base-2` to an existing Pixeltable column `tbl.sentence` of the table `tbl`:
```python
tbl.add_computed_column(
    result=sentence_transformer(
        tbl.sentence, model_id='all-mpnet-base-v2'
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; speech2text_for_conditional_generation()

```python Signature
@pxt.udf
speech2text_for_conditional_generation(
    audio: pxt.Audio,
    *,
    model_id: pxt.String,
    language: pxt.String | None = None
) -> pxt.String
```

Transcribes or translates speech to text using a Speech2Text model. `model_id` should be a reference to a
pretrained [Speech2Text](https://huggingface.co/docs/transformers/en/model_doc/speech_to_text) model.

__Requirements:__

- `pip install torch torchaudio sentencepiece transformers`

**Parameters:**

- **`audio`** (`pxt.Audio`): The audio clip to transcribe or translate.
- **`model_id`** (`pxt.String`): The pretrained model to use for the transcription or translation.
- **`language`** (`pxt.String | None`): If using a multilingual translation model, the language code to translate to. If not provided,
    the model's default language will be used. If the model is not translation model, is not a
    multilingual model, or does not support the specified language, an error will be raised.

**Returns:**

- `pxt.String`: The transcribed or translated text.

**Examples:**

Add a computed column that applies the model `facebook/s2t-small-librispeech-asr` to an existing Pixeltable column `audio` of the table `tbl`:
```python
tbl.add_computed_column(
    transcription=speech2text_for_conditional_generation(
        tbl.audio, model_id='facebook/s2t-small-librispeech-asr'
    )
)
```

Add a computed column that applies the model `facebook/s2t-medium-mustc-multilingual-st` to an existing Pixeltable column `audio` of the table `tbl`, translating the audio to French:
```python
tbl.add_computed_column(
    translation=speech2text_for_conditional_generation(
        tbl.audio,
        model_id='facebook/s2t-medium-mustc-multilingual-st',
        language='fr',
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; summarization()

```python Signature
@pxt.udf
summarization(
    text: pxt.String,
    *,
    model_id: pxt.String,
    model_kwargs: pxt.Json | None = None
) -> pxt.String
```

Summarizes text using a pretrained summarization model. `model_id` should be a reference to a pretrained
[summarization model](https://huggingface.co/models?pipeline_tag=summarization) such as BART, T5, or Pegasus.

__Requirements:__

- `pip install torch transformers`

**Parameters:**

- **`text`** (`pxt.String`): The text to summarize.
- **`model_id`** (`pxt.String`): The pretrained model to use for summarization.
- **`model_kwargs`** (`pxt.Json | None`): Additional keyword arguments to pass to the model's `generate` method, such as `max_length`.

**Returns:**

- `pxt.String`: The generated summary text.

**Examples:**

Add a computed column that summarizes documents:
```python
tbl.add_computed_column(
    summary=text_summarization(
        tbl.document_text,
        model_id='facebook/bart-large-cnn',
        max_length=100,
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; text_classification()

```python Signature
@pxt.udf
text_classification(
    text: pxt.String,
    *,
    model_id: pxt.String,
    top_k: pxt.Int = 5
) -> pxt.Json
```

Classifies text using a pretrained classification model. `model_id` should be a reference to a pretrained
[text classification model](https://huggingface.co/models?pipeline_tag=text-classification)
such as BERT, RoBERTa, or DistilBERT.

__Requirements:__

- `pip install torch transformers`

**Parameters:**

- **`text`** (`pxt.String`): The text to classify.
- **`model_id`** (`pxt.String`): The pretrained model to use for classification.
- **`top_k`** (`pxt.Int`): The number of top predictions to return.

**Returns:**

- `pxt.Json`: A dictionary containing classification results with scores, labels, and label text.

**Examples:**

Add a computed column for sentiment analysis:
```python
tbl.add_computed_column(
    sentiment=text_classification(
        tbl.review_text,
        model_id='cardiffnlp/twitter-roberta-base-sentiment-latest',
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; text_generation()

```python Signature
@pxt.udf
text_generation(
    text: pxt.String,
    *,
    model_id: pxt.String,
    model_kwargs: pxt.Json | None = None
) -> pxt.String
```

Generates text using a pretrained language model. `model_id` should be a reference to a pretrained
[text generation model](https://huggingface.co/models?pipeline_tag=text-generation).

__Requirements:__

- `pip install torch transformers`

**Parameters:**

- **`text`** (`pxt.String`): The input text to continue/complete.
- **`model_id`** (`pxt.String`): The pretrained model to use for text generation.
- **`model_kwargs`** (`pxt.Json | None`): Additional keyword arguments to pass to the model's `generate` method, such as `max_length`,
    `temperature`, etc. See the
    [Hugging Face text_generation documentation](https://huggingface.co/docs/inference-providers/en/tasks/text-generation)
    for details.

**Returns:**

- `pxt.String`: The generated text completion.

**Examples:**

Add a computed column that generates text completions using the `Qwen/Qwen3-0.6B` model:
```python
tbl.add_computed_column(
    completion=text_generation(
        tbl.prompt,
        model_id='Qwen/Qwen3-0.6B',
        model_kwargs={'temperature': 0.5, 'max_length': 150},
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; text_to_image()

```python Signature
@pxt.udf
text_to_image(
    prompt: pxt.String,
    *,
    model_id: pxt.String,
    height: pxt.Int = 512,
    width: pxt.Int = 512,
    seed: pxt.Int | None = None,
    model_kwargs: pxt.Json | None = None
) -> pxt.Image
```

Generates images from text prompts using a pretrained text-to-image model. `model_id` should be a reference to a
pretrained [text-to-image model](https://huggingface.co/models?pipeline_tag=text-to-image) such as
Stable Diffusion.

__Requirements:__

- `pip install torch transformers diffusers accelerate`

**Parameters:**

- **`prompt`** (`pxt.String`): The text prompt describing the desired image.
- **`model_id`** (`pxt.String`): The pretrained text-to-image model to use.
- **`height`** (`pxt.Int`): Height of the generated image in pixels.
- **`width`** (`pxt.Int`): Width of the generated image in pixels.
- **`seed`** (`pxt.Int | None`): Optional random seed for reproducibility.
- **`model_kwargs`** (`pxt.Json | None`): Additional keyword arguments to pass to the model, such as `num_inference_steps`,
    `guidance_scale`, or `negative_prompt`.

**Returns:**

- `pxt.Image`: The generated Image.

**Examples:**

Add a computed column that generates images from text prompts:
```python
tbl.add_computed_column(
    generated_image=text_to_image(
        tbl.prompt,
        model_id='stable-diffusion-v1.5/stable-diffusion-v1-5',
        height=512,
        width=512,
        model_kwargs={'num_inference_steps': 25},
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; text_to_speech()

```python Signature
@pxt.udf
text_to_speech(
    text: pxt.String,
    *,
    model_id: pxt.String,
    speaker_id: pxt.Int | None = None,
    vocoder: pxt.String | None = None
) -> pxt.Audio
```

Converts text to speech using a pretrained TTS model. `model_id` should be a reference to a
pretrained [text-to-speech model](https://huggingface.co/models?pipeline_tag=text-to-speech).

__Requirements:__

- `pip install torch transformers datasets soundfile`

**Parameters:**

- **`text`** (`pxt.String`): The text to convert to speech.
- **`model_id`** (`pxt.String`): The pretrained TTS model to use.
- **`speaker_id`** (`pxt.Int | None`): Speaker ID for multi-speaker models.
- **`vocoder`** (`pxt.String | None`): Optional vocoder model for higher quality audio.

**Returns:**

- `pxt.Audio`: The generated audio file.

**Examples:**

Add a computed column that converts text to speech:
```python
tbl.add_computed_column(
    audio=text_to_speech(
        tbl.text_content, model_id='microsoft/speecht5_tts', speaker_id=0
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; token_classification()

```python Signature
@pxt.udf
token_classification(
    text: pxt.String,
    *,
    model_id: pxt.String,
    aggregation_strategy: pxt.String = 'simple'
) -> pxt.Json
```

Extracts named entities from text using a pretrained named entity recognition (NER) model.
`model_id` should be a reference to a pretrained
[token classification model](https://huggingface.co/models?pipeline_tag=token-classification) for NER.

__Requirements:__

- `pip install torch transformers`

**Parameters:**

- **`text`** (`pxt.String`): The text to analyze for named entities.
- **`model_id`** (`pxt.String`): The pretrained model to use.
- **`aggregation_strategy`** (`pxt.String`): Method used to aggregate tokens.

**Returns:**

- `pxt.Json`: A list of dictionaries containing entity information (text, label, confidence, start, end).

**Examples:**

Add a computed column that extracts named entities:
```python
tbl.add_computed_column(
    entities=token_classification(
        tbl.text,
        model_id='dbmdz/bert-large-cased-finetuned-conll03-english',
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; translation()

```python Signature
@pxt.udf
translation(
    text: pxt.String,
    *,
    model_id: pxt.String,
    src_lang: pxt.String | None = None,
    target_lang: pxt.String | None = None
) -> pxt.String
```

Translates text using a pretrained translation model. `model_id` should be a reference to a pretrained
[translation model](https://huggingface.co/models?pipeline_tag=translation) such as MarianMT or T5.

__Requirements:__

- `pip install torch transformers sentencepiece`

**Parameters:**

- **`text`** (`pxt.String`): The text to translate.
- **`model_id`** (`pxt.String`): The pretrained translation model to use.
- **`src_lang`** (`pxt.String | None`): Source language code (optional, can be inferred from model).
- **`target_lang`** (`pxt.String | None`): Target language code (optional, can be inferred from model).

**Returns:**

- `pxt.String`: The translated text.

**Examples:**

Add a computed column that translates text:
```python
tbl.add_computed_column(
    french_text=translation(
        tbl.english_text,
        model_id='Helsinki-NLP/opus-mt-en-fr',
        src_lang='en',
        target_lang='fr',
    )
)
```


## <span style={{ 'color': 'gray' }}>udf</span>&nbsp; vit_for_image_classification()

```python Signature
@pxt.udf
vit_for_image_classification(
    image: pxt.Image,
    *,
    model_id: pxt.String,
    top_k: pxt.Int = 5
) -> pxt.Json
```

Computes image classifications for the specified image using a Vision Transformer (ViT) model.
`model_id` should be a reference to a pretrained [ViT Model](https://huggingface.co/docs/transformers/en/model_doc/vit).

__Note:__ Be sure the model is a ViT model that is trained for image classification (that is, a model designed for
use with the
[ViTForImageClassification](https://huggingface.co/docs/transformers/en/model_doc/vit#transformers.ViTForImageClassification)
class), such as `google/vit-base-patch16-224`. General feature-extraction models such as
`google/vit-base-patch16-224-in21k` will not produce the desired results.

__Requirements:__

- `pip install torch transformers`

**Parameters:**

- **`image`** (`pxt.Image`): The image to classify.
- **`model_id`** (`pxt.String`): The pretrained model to use for the classification.
- **`top_k`** (`pxt.Int`): The number of classes to return.

**Returns:**

- `pxt.Json`: A dictionary containing the output of the image classification model, in the following format:
  ```python
  {
      'scores': [0.325, 0.198, 0.105],  # list of probabilities of the top-k most likely classes
      'labels': [340, 353, 386],  # list of class IDs for the top-k most likely classes
      'label_text': ['zebra', 'gazelle', 'African elephant, Loxodonta africana'],
          # corresponding text names of the top-k most likely classes
  ```

**Examples:**

Add a computed column that applies the model `google/vit-base-patch16-224` to an existing Pixeltable column `image` of the table `tbl`, returning the 10 most likely classes for each image:
```python
tbl.add_computed_column(
    image_class=vit_for_image_classification(
        tbl.image, model_id='google/vit-base-patch16-224', top_k=10
    )
)
```

