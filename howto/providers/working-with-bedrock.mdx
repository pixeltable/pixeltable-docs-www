---
title: "Working with Bedrock in Pixeltable"
sidebarTitle: "Bedrock"
icon: "notebook"
---
<a href="https://kaggle.com/kernels/welcome?src=https://github.com/pixeltable/pixeltable/blob/release/docs/release/howto/providers/working-with-bedrock.ipynb" id="openKaggle" target="_blank" rel="noopener noreferrer"><img src="https://kaggle.com/static/images/open-in-kaggle.svg" alt="Open in Kaggle" style={{ display: 'inline', margin: '0px' }} noZoom /></a>&nbsp;&nbsp;<a href="https://colab.research.google.com/github/pixeltable/pixeltable/blob/release/docs/release/howto/providers/working-with-bedrock.ipynb" id="openColab" target="_blank" rel="noopener noreferrer"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open in Colab" style={{ display: 'inline', margin: '0px' }} noZoom /></a>&nbsp;&nbsp;<a href="https://raw.githubusercontent.com/pixeltable/pixeltable/refs/tags/release/docs/release/howto/providers/working-with-bedrock.ipynb" id="downloadNotebook" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/%E2%AC%87-Download%20Notebook-blue" alt="Download Notebook" style={{ display: 'inline', margin: '0px' }} noZoom /></a>

<Tip>This documentation page is also available as an interactive notebook. You can launch the notebook in
Kaggle or Colab, or download it for use with an IDE or local Jupyter installation, by clicking one of the
above links.</Tip>




Pixeltable’s Bedrock integration enables you to access AWS Bedrock via
the Bedrock API.

### Prerequisites

-   Activate Bedrock in your AWS account.
-   Request access to your desired models (e.g. Claude Sonnet 3.7,
    Amazon Nova Pro)
-   Optional - you may need to configure AWS CLI locally to authenticate
    with your AWS account.

### Important notes

-   Bedrock usage may incur costs based on your Bedrock plan.
-   Be mindful of sensitive data and consider security measures when
    integrating with external services.

First you’ll need to install required libraries and enter an Bedrock API
key.


```python
%pip install -qU pixeltable boto3 duckduckgo-search
```


```python
import os
import getpass

if 'AWS_ACCESS_KEY' not in os.environ:
    os.environ['AWS_ACCESS_KEY'] = getpass.getpass(
        'Enter your AWS Access Key:'
    )

if 'AWS_SECRET_ACCESS_KEY' not in os.environ:
    os.environ['AWS_SECRET_ACCESS_KEY'] = getpass.getpass(
        'Enter your AWS Secret Access Key:'
    )
```

Now let’s create a Pixeltable directory to hold the tables for our demo.


```python
import pixeltable as pxt

# Remove the `bedrock_demo` directory and its contents, if it exists
pxt.drop_dir('bedrock_demo', force=True)
pxt.create_dir('bedrock_demo')
```

## Basic messages

Create a Table: In Pixeltable, create a table with columns to represent
your input data and the columns where you want to store the results from
Bedrock.


```python
from pixeltable.functions import bedrock

# Create a table in Pixeltable and pick a model hosted on Bedrock with some parameters

t = pxt.create_table('bedrock_demo.chat', {'input': pxt.String})

msgs = [{'role': 'user', 'content': t.input}]
t.add_computed_column(
    output=bedrock.converse(
        model_id='amazon.nova-pro-v1:0',
        messages=[{'role': 'user', 'content': [{'text': t.input}]}],
    )
)
```


```python
# Parse the response into a new column
t.add_computed_column(response=t.output.output.message.content[0].text)
```


```python
# Start a conversation
t.insert(
    [
        {
            'input': 'What was the outcome of the 1904 US Presidential election?'
        }
    ]
)
t.select(t.input, t.response).show()
```

## Advanced: Tool-based agent with Bedrock

Now let’s create a more advanced example using Bedrock with tools for
news search and weather information.


```python
import pixeltable as pxt
import pixeltable.functions as pxtf
from pixeltable.functions.bedrock import converse, invoke_tools
from duckduckgo_search import DDGS

# Initialize app structure
pxt.drop_dir('agents', force=True)
pxt.create_dir('agents')
```


```python
# Define tools
@pxt.udf
def search_news(keywords: str, max_results: int) -> str:
    """Search news using DuckDuckGo and return results."""
    try:
        with DDGS() as ddgs:
            results = ddgs.news(
                keywords=keywords,
                region='wt-wt',
                safesearch='off',
                timelimit='m',
                max_results=max_results,
            )
            formatted_results = []
            for i, r in enumerate(results, 1):
                formatted_results.append(
                    f'{i}. Title: {r["title"]}\n'
                    f'   Source: {r["source"]}\n'
                    f'   Published: {r["date"]}\n'
                    f'   Snippet: {r["body"]}\n'
                )
            return '\n'.join(formatted_results)
    except Exception as e:
        return f'Search failed: {str(e)}'


@pxt.udf
def get_weather(location: str) -> str:
    """Mock weather function - replace with actual API call."""
    return f'Current weather in {location}: 72°F, Partly Cloudy'


# Register all tools
tools = pxt.tools(search_news, get_weather)
```


```python
# Create base table
tool_agent = pxt.create_table(
    'agents.tools', {'prompt': pxt.String}, if_exists='ignore'
)

# Add tool selection and execution workflow
tool_agent.add_computed_column(
    initial_response=converse(
        model_id='amazon.nova-pro-v1:0',
        messages=[
            {'role': 'user', 'content': [{'text': tool_agent.prompt}]}
        ],
        tool_config=tools,
    )
)

# Add tool execution
tool_agent.add_computed_column(
    tool_output=invoke_tools(tools, tool_agent.initial_response)
)
```


```python
# Add response formatting
tool_agent.add_computed_column(
    tool_response_prompt=pxtf.string.format(
        'Orginal Prompt\n{0}: Tool Output\n{1}',
        tool_agent.prompt,
        tool_agent.tool_output,
    ),
    if_exists='ignore',
)

# Add final response generation
tool_agent.add_computed_column(
    final_response=converse(
        model_id='amazon.nova-pro-v1:0',
        messages=[
            {
                'role': 'user',
                'content': [{'text': tool_agent.tool_response_prompt}],
            }
        ],
    )
)

tool_agent.add_computed_column(
    answer=tool_agent.final_response.output.message.content[0].text
)
```


```python
# Example queries using different tools
queries = [
    "What's the latest news about SpaceX?",
    "What's the weather in San Francisco?",
]

# Use the agent
for query in queries:
    tool_agent.insert([{'prompt': query}])
    result = tool_agent.select(
        tool_agent.prompt, tool_agent.tool_output, tool_agent.answer
    ).tail(1)

# Display the full table
tool_agent.select(tool_agent.prompt, tool_agent.answer).show()
```

## How it works

This notebook demonstrates two key Bedrock integration patterns:

1.  **Basic Message Completion**: Using the `bedrock.messages()`
    function to generate responses from Bedrock models.

2.  **Tool-based Agent**: Using `bedrock.converse()` and
    `bedrock.invoke_tools()` to create an agent that can:

    -   Analyze user queries
    -   Select appropriate tools (news search or weather)
    -   Execute the tools to retrieve information
    -   Generate a final response based on the tool output

This pattern demonstrates how Pixeltable can be used as an agent
engineering framework, allowing you to create complex, multi-step
workflows with LLMs and external tools.

### Learn more

To learn more about advanced techniques like RAG operations in
Pixeltable, check out the [RAG Operations in
Pixeltable](/howto/use-cases/rag-operations)
tutorial.

For more on agent engineering with Pixeltable, see the [PixelAgent
documentation](/libraries/pixelagent).

If you have any questions, don’t hesitate to reach out.
