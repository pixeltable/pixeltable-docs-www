---
title: "Use a table pipeline as a reusable function"
sidebarTitle: "Use a table pipeline as a reusable function"
icon: "notebook"
---
<a href="https://kaggle.com/kernels/welcome?src=https://github.com/pixeltable/pixeltable/blob/release/docs/release/howto/cookbooks/agents/pattern-table-as-udf.ipynb" id="openKaggle" target="_blank" rel="noopener noreferrer"><img src="https://kaggle.com/static/images/open-in-kaggle.svg" alt="Open in Kaggle" style={{ display: 'inline', margin: '0px' }} noZoom /></a>&nbsp;&nbsp;<a href="https://colab.research.google.com/github/pixeltable/pixeltable/blob/release/docs/release/howto/cookbooks/agents/pattern-table-as-udf.ipynb" id="openColab" target="_blank" rel="noopener noreferrer"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open in Colab" style={{ display: 'inline', margin: '0px' }} noZoom /></a>&nbsp;&nbsp;<a href="https://raw.githubusercontent.com/pixeltable/pixeltable/refs/tags/release/docs/release/howto/cookbooks/agents/pattern-table-as-udf.ipynb" id="downloadNotebook" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/%E2%AC%87-Download%20Notebook-blue" alt="Download Notebook" style={{ display: 'inline', margin: '0px' }} noZoom /></a>

<Tip>This documentation page is also available as an interactive notebook. You can launch the notebook in
Kaggle or Colab, or download it for use with an IDE or local Jupyter installation, by clicking one of the
above links.</Tip>




export const quartoRawHtml =
[`
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 32%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr>
<th>Scenario</th>
<th>Pipeline</th>
<th>Consumers</th>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: middle;">Research agent</td>
<td style="vertical-align: middle;">Web search → LLM analysis → Summary</td>
<td style="vertical-align: middle;">Report generator, Dashboard</td>
</tr>
<tr>
<td style="vertical-align: middle;">Data enrichment</td>
<td style="vertical-align: middle;">Lookup → Transform → Validate</td>
<td style="vertical-align: middle;">Orders table, Analytics</td>
</tr>
<tr>
<td style="vertical-align: middle;">Content moderation</td>
<td style="vertical-align: middle;">Vision analysis → Text check → Score</td>
<td style="vertical-align: middle;">User uploads, Comments</td>
</tr>
</tbody>
</table>
`,`
<table>
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th>Pattern</th>
<th>Use when</th>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: middle;">Table UDF</td>
<td style="vertical-align: middle;">You need to run a multi-step pipeline (LLM → process → LLM)</td>
</tr>
<tr>
<td style="vertical-align: middle;"><code>@pxt.query</code></td>
<td style="vertical-align: middle;">You need to retrieve/search existing data</td>
</tr>
<tr>
<td style="vertical-align: middle;"><code>@pxt.udf</code></td>
<td style="vertical-align: middle;">You need a pure Python transformation</td>
</tr>
</tbody>
</table>
`];

Convert a table with computed columns into a callable function for
multi-agent workflows and pipeline composition.

## Problem

You have a table that runs a complex pipeline—LLM calls, tool use,
post-processing—and you want to reuse that entire pipeline from other
tables. Copy-pasting computed column definitions is error-prone and hard
to maintain.

<div style={{ 'margin': '0px 20px 0px 20px' }} dangerouslySetInnerHTML={{ __html: quartoRawHtml[0] }} />

## Solution

**What’s in this recipe:** - Create an “agent” table with computed
columns - Convert the table to a callable UDF with
`pxt.udf(table, return_value=...)` - Use the table UDF in other tables’
computed columns

You wrap an entire table pipeline as a function. When you call this
function from another table, it inserts a row into the agent table, runs
all computed columns, and returns the specified output column.

### Setup


```python
%pip install -qU pixeltable openai

```

<pre style={{ 'margin': '-20px 20px 0px 20px', 'padding': '0px', 'background-color': 'transparent', 'color': 'black' }}>
WARNING:&nbsp;Ignoring&nbsp;invalid&nbsp;distribution&nbsp;~orch&nbsp;(/opt/miniconda3/envs/pixeltable/lib/python3.11/site-packages)
WARNING:&nbsp;Ignoring&nbsp;invalid&nbsp;distribution&nbsp;~orch&nbsp;(/opt/miniconda3/envs/pixeltable/lib/python3.11/site-packages)
WARNING:&nbsp;Ignoring&nbsp;invalid&nbsp;distribution&nbsp;~orch&nbsp;(/opt/miniconda3/envs/pixeltable/lib/python3.11/site-packages)
&nbsp;&nbsp;&nbsp;&nbsp;WARNING:&nbsp;Ignoring&nbsp;invalid&nbsp;distribution&nbsp;~orch&nbsp;(/opt/miniconda3/envs/pixeltable/lib/python3.11/site-packages)
WARNING:&nbsp;Ignoring&nbsp;invalid&nbsp;distribution&nbsp;~orch&nbsp;(/opt/miniconda3/envs/pixeltable/lib/python3.11/site-packages)
WARNING:&nbsp;Ignoring&nbsp;invalid&nbsp;distribution&nbsp;~orch&nbsp;(/opt/miniconda3/envs/pixeltable/lib/python3.11/site-packages)
WARNING:&nbsp;Ignoring&nbsp;invalid&nbsp;distribution&nbsp;~orch&nbsp;(/opt/miniconda3/envs/pixeltable/lib/python3.11/site-packages)
Note:&nbsp;you&nbsp;may&nbsp;need&nbsp;to&nbsp;restart&nbsp;the&nbsp;kernel&nbsp;to&nbsp;use&nbsp;updated&nbsp;packages.
</pre>


```python
import os
import getpass

if 'OPENAI_API_KEY' not in os.environ:
    os.environ['OPENAI_API_KEY'] = getpass.getpass('OpenAI API Key: ')

```


```python
import pixeltable as pxt
from pixeltable.functions.openai import chat_completions

```


```python
# Create a fresh directory
pxt.drop_dir('table_udf_demo', force=True)
pxt.create_dir('table_udf_demo')

```

### Create an agent table with computed columns

You create a table that encapsulates a complete pipeline. This example
builds a summarization agent:


```python
# Create the agent table with input column
summarizer = pxt.create_table(
    'table_udf_demo.summarizer',
    {'text': pxt.String}
)

```


```python
# Add the LLM call as a computed column
summarizer.add_computed_column(
    response=chat_completions(
        messages=[{
            'role': 'user',
            'content': 'Summarize this in one sentence:\n\n' + summarizer.text
        }],
        model='gpt-4o-mini'
    )
)

```


```python
# Extract the summary text
summarizer.add_computed_column(
    summary=summarizer.response.choices[0].message.content
)

```

### Convert the table to a UDF

You use `pxt.udf(table, return_value=...)` to convert the table into a
callable function. The `return_value` specifies which column to return:


```python
# Convert the summarizer table into a callable UDF
summarize = pxt.udf(
    summarizer,
    return_value=summarizer.summary
)

```

### Use the table UDF in another table

You can now use `summarize()` as a computed column in any other table:


```python
# Create a table that uses the summarizer
articles = pxt.create_table(
    'table_udf_demo.articles',
    {'title': pxt.String, 'content': pxt.String}
)

```


```python
# Add the table UDF as a computed column
articles.add_computed_column(
    summary=summarize(text=articles.content)
)

```


```python
# Insert articles - summaries are generated automatically
articles.insert([
    {
        'title': 'Climate Report',
        'content': 'Global temperatures rose by 1.2 degrees Celsius above pre-industrial levels last year, marking the hottest year on record. Scientists attribute this to continued greenhouse gas emissions and a strong El Nino pattern. The report calls for immediate action to reduce carbon emissions.'
    },
    {
        'title': 'Tech Merger',
        'content': 'Two major semiconductor companies announced a merger valued at $50 billion. The combined entity will control 30% of the global chip market. Regulators in multiple countries will review the deal over the next 18 months.'
    },
])

```


```python
# View results
articles.select(articles.title, articles.summary).collect()

```

### Chain multiple table UDFs

You can compose table UDFs by using one’s output as another’s input:


```python
# Create a translator agent table
translator = pxt.create_table(
    'table_udf_demo.translator',
    {'text': pxt.String}
)

translator.add_computed_column(
    response=chat_completions(
        messages=[{
            'role': 'user',
            'content': 'Translate to Spanish:\n\n' + translator.text
        }],
        model='gpt-4o-mini'
    )
)

translator.add_computed_column(
    translation=translator.response.choices[0].message.content
)

```


```python
# Convert to UDF
translate = pxt.udf(
    translator,
    return_value=translator.translation
)

```


```python
# Chain: summarize first, then translate the summary
articles.add_computed_column(
    summary_es=translate(text=articles.summary)
)

```


```python
# View the chain results
articles.select(articles.title, articles.summary, articles.summary_es).collect()

```

## Explanation

**How table UDFs work:**

<pre style={{ 'margin': '-20px 20px 0px 20px', 'padding': '0px', 'background-color': 'transparent', 'color': 'black' }}>
Consumer&nbsp;table&nbsp;row&nbsp;→&nbsp;Table&nbsp;UDF&nbsp;called&nbsp;→&nbsp;Agent&nbsp;table&nbsp;inserts&nbsp;row&nbsp;→&nbsp;
Computed&nbsp;columns&nbsp;run&nbsp;→&nbsp;Return&nbsp;value&nbsp;extracted&nbsp;→&nbsp;Consumer&nbsp;gets&nbsp;result
</pre>

**When to use table UDFs vs `@pxt.query`:**

<div style={{ 'margin': '0px 20px 0px 20px' }} dangerouslySetInnerHTML={{ __html: quartoRawHtml[1] }} />

**Key benefits:** - **Encapsulation**: Hide complex pipeline details
behind a simple function call - **Reusability**: Use the same agent from
multiple consumer tables - **Persistence**: All intermediate results are
stored in the agent table for debugging - **Composition**: Chain agents
together for multi-stage workflows

## See also

-   [Look up structured
    data](/howto/cookbooks/agents/pattern-data-lookup) -
    Simple key-based lookups with `retrieval_udf`
-   [Build a RAG
    pipeline](/howto/cookbooks/agents/pattern-rag-pipeline) -
    Retrieval with `@pxt.query`
-   [Use tool calling with
    LLMs](/howto/cookbooks/agents/llm-tool-calling) -
    Add tools to agent tables
